// dh parameters UR5e
// Voraussetzung der IK: ortho-parallel basis alpha1=+-pi/2, alpha2=-pi,0 oder pi,
// d.h. die ersten beiden Achsen senkrecht aufeinander und die 2. und 3. Achse parallel

a_2 := -0.425
a_3 := -0.3922
d_1 := 0.1625
d_4 := 0.1333
d_5 := 0.0997
d_6 := 0.0996

// position of the end-effector 
P_e := p+0.5p²εᵢ+ε₀

// position joint 5
t := p-(d_6 ae)
P_5 := t+0.5t²εᵢ+ε₀ // ipns

// sphere around P_5
Sc := P_5-0.5d_4²εᵢ // ipns

// sphere around the origin
K_0 := ε₀+(Sc⋅ε₀)εᵢ // ipns

// intersection of Sc and K_0
C_5k := Sc^K_0

// intersection of C5k and the horizontal plane through P5
Pl := P_5∧ε₁^ε₂^εᵢ
Q_c := C_5k⌋Pl // opns 

// point Pc with an offset d4 from P5
// da war vorher - vor sqrt
P_c := (Q_c+sqrt(abs(Q_c²)))/(-εᵢ⌋Q_c) //P_c = ExtractFirstPoint(Qc) ipns

// Extraction of eudlidean part
// To map a conformal vector back into a vector from the original space, the 
// vector is first normalized, then rejected from the minkowski plane 
// Perwass equ. 4.37
P_cn := P_c/(εᵢ⌋P_c)  // 1. Normalisierung $$ X = \frac{X}{X \cdot e_{\infty}}$$
P_ce := (P_cn∧E₀)/E₀  // 2. Rejection from the Minkovski-Plane  $$x = X \wedge E_0\, E_0^{-1}$$

// plane through joints 1, 2, 3 and 4
Pi_c := (ε₀∧ε₃∧P_ce∧εᵢ) // opns P_ce vom Typ euclidean-vector

// finding P4
// plane parallel to Pi_c that contains P4 and P5
// Warum geht das so?
Pic_parallel := Pi_c* + (P_5⋅Pi_c*)εᵢ // eq. 47 ipns
// plane between P_5 and P_e orthogonal to Pi_c and Pic_parallel
// Warum geht das so?
Pi56_orthogonal := (P_5∧P_e)*∧εᵢ // eq. 48 l.1 opns

n56_orthogonal  := normalize(-(Pi56_orthogonal⌊ε₀)⌊εᵢ)

Pic_orthogonal := (P_5∧n56_orthogonal∧εᵢ)* // ipns

L_45 := Pic_parallel∧Pic_orthogonal // ipns

S_5  := P_5-(0.5d_5²εᵢ) // ipns
Q_4  := L_45*⌊S_5 // opns grade-2
P_4 := (Q_4-sqrt(abs(Q_4²)))/(-εᵢ⌋Q_4) // ipns grade-1

// finding P3
S_4  := P_4 + (0.5d_4²εᵢ) // ipns - Kugel um P4 mit radius d4, P3 liegt auf S_4
L_34 := P_4∧Pi_c*∧εᵢ // opns - Linie durch P4 mit Normalenvektor von Pi_c als Richtung
Q_3  := L_34⌊S_4 // opns grade-2
// + für second solution ist richtig, liegt also im Gelenkzentrum
P_3 := (Q_3+sqrt(abs(Q_3²)))/(-εᵢ⌋Q_3) // ipns WORKAROUND abs() - da das Argument der Wurzel negativ sein kann

// finding P1 
P_1 := d_1ε₃+0.5d_1²εᵢ+ε₀ //P_1 := createPoint(0, 0, d1)

// finding P2 by intersection of of two spheres with the veritcal plane
S_1 := P_1-0.5a_2²εᵢ // ipns
S_3 := P_3-0.5a_3²εᵢ // ipns "-" statt "+" im cluscript entspricht Bachelor-Arbeit
C_2 := S_1∧S_3 // ipns
Q_2 := C_2⌋Pi_c // opns
P_2 := (Q_2-sqrt(abs(Q_2²)))/(-εᵢ⌋Q_2) 

//TODO falls robot of class A or C represented by a3 !=0
// dann müssen P_2v etc. bestimmt werden

// joint angles

L_01 := ε₀∧ε₃∧εᵢ // opns
L_12 := P_1∧P_2∧εᵢ // opns
L_23 := (P_2∧P_3∧εᵢ) // opns

P_0 := ε₀

// 1. joint (base)
a_1 := ε₂
b_1 := -Pi_c // *k1
N_1 := ε₁∧ε₂
//x_1 := (a_1∧b_1)/N_1
//y_1 := a_1⋅b_1

// 2. joint (shoulder) ok
a_2 := L_01⌊ε₀⌊εᵢ
b_2 := L_12⌊ε₀⌊εᵢ
N_2 := -Pi_c⌊ε₀⌊εᵢ // *k1
x_2 := (a_2∧b_2)/N_2
y_2 := a_2⋅b_2

// 3. joint (elbow) ok
a_3 := L_12⌊ε₀⌊εᵢ
b_3 := L_23⌊ε₀⌊εᵢ
N_3 := -(Pi_c⌊ε₀)⌊εᵢ
x_3 := (a_3∧b_3)/N_3
y_3 := a_3⋅b_3

// 4. joint (wrist-1)
a_4 := (L_23⌊ε₀)⌊εᵢ
b_4 := (L_45*⌊ε₀)⌊εᵢ
N_4 := -(Pi_c⌊ε₀)⌊εᵢ
x_4 := (a_4∧b_4)/N_4
y_4 := a_4⋅b_4

// 5. joint (wrist-2)
a_5 := P_c // *k1
b_5 := -ae
N_5 := (-L_45∧ε₀)⌊εᵢ
x_5 := (a_5∧b_5)/N_5
y_5 := a_5⋅b_5

// 6. joint (TCP)
a_6 := L_45*⌊ε₀⌊εᵢ
b_6 := -se
N_6 := -ae* // * statt (ε₃^ε₂^ε₁)
x_6 := (a_6∧b_6)/N_6
y_6 := a_6⋅b_6

P_e, P_5, Sc, K_0, C_5k, Pl, Q_c, P_c, P_ce, Pi_c, Pic_parallel, Pi56_orthogonal, n56_orthogonal, Pic_orthogonal, L_45, S_5, Q_4, P_4, S_4, L_34, Q_3, P_3, P_1, S_1, S_3, C_2, Q_2, P_2, L_01, L_12, L_23, a_1, b_1, N_1, a_2, b_2, N_2, a_3, b_3, N_3, a_4, b_4, N_4, a_5, b_5, N_5, a_6, b_6, N_6